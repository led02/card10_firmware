<!--
  Copyright (c) 2013-2018 Arm Ltd. All Rights Reserved.
  Arm Limited confidential and proprietary.
-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Attribute Profile (ATT)</title>
<title>Cordio Stack and Cordio Profiles: Attribute Profile (ATT)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="printComponentTabs.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="DoxygenStyleSheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 46px;">
  <td id="projectlogo">&#160;<img alt="Logo" src="Arm_Cordio.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">&#160;&#160;&#160;Cordio Stack and Cordio Profiles
   &#160;<span id="projectnumber">r2p3-02rel0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<div id="BLEnav" class="tabs1">
    <ol id="Tabs" class="tablist">
      <script type="text/javascript">
        <!--
        writeComponentTabs.call(this);
        //-->
      </script>
    </ol>
</div>
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Usage&#160;and&#160;Description</span></a></li>
      <li class="current"><a href="modules.html"><span>Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___s_t_a_c_k___a_t_t.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Content</a>  </div>
  <div class="headertitle">
<div class="title">Attribute Profile (ATT)<div class="ingroups"><a class="el" href="group___b_l_e___s_t_a_c_k.html">ble-stack</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Content</h2></td></tr>
<tr class="memitem:group___s_t_a_c_k___a_t_t___a_p_i"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_t_a_c_k___a_t_t___a_p_i.html">ATT API</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___s_t_a_c_k___a_t_t_s___a_p_i"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_t_a_c_k___a_t_t_s___a_p_i.html">ATT Server API</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___s_t_a_c_k___a_t_t_c___a_p_i"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_t_a_c_k___a_t_t_c___a_p_i.html">ATT Client API</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<h1><a class="anchor" id="ATT_INTRO"></a>
Introduction</h1>
<div class="image">
<img src="diagram_att.png" alt="diagram_att.png"/>
<div class="caption">
Figure 1. BLE Stack: ATT</div></div>
<p> The ATT subsystem implements the attribute protocol and generic attribute profile. It contains two independent subsystems:</p><ul>
<li>The attribute protocol client (ATTC). ATTC implements all attribute protocol client features and is designed to meet the client requirements of the generic attribute profile. ATTC may support multiple simultaneous connections to different servers.</li>
<li>The attribute protocol server (ATTS). ATTS implements all attribute protocol server features and has support for multiple simultaneous client connections. ATTS also implements the server features defined by the generic attribute profile.</li>
</ul>
<p>An ATT layer below ATTC and ATTS implements routing of received attribute protocol messages to either ATTC or ATTS.<br />
<br />
 For full generic ATT Interface, see <a class="el" href="group___s_t_a_c_k___a_t_t___a_p_i.html">ATT API</a>.</p>
<h1><a class="anchor" id="ATT_ATTS"></a>
ATT Server</h1>
<p>This API controls the operation of the attribute protocol server (ATTS). For server interface, see <a class="el" href="group___s_t_a_c_k___a_t_t_s___a_p_i.html">ATT Server API</a>.<br />
<br />
 An attribute server provides access to an attribute database stored within the server. According to the Bluetooth specification, attributes are collected into groups of characteristics, which are further collected into a service. A service is a collection of characteristics designed to accomplish a particular function, such as an alert service or a sensor service.<br />
<br />
 Figure 2 shows how services, characteristics, and attributes are organized according to the Bluetooth specification. An attribute database typically contains one or more services. Each service contains a set of characteristics, which is made up of one or more attributes. The type of attribute is uniquely identified by a UUID and an instance of an attribute in a server is uniquely identified by a handle. An attribute typically contains data that can be read or written by the attribute client on a peer device.</p>
<div class="image">
<img src="diagram_atts.png" alt="diagram_atts.png"/>
<div class="caption">
Figure 2. Services, characteristics, and attributes stored in an attribute server</div></div>
<p> In the ATTS implementation, the attribute database consists of a linked list of one or more group structures. Each attribute group structure points to an array of attribute structures. Each attribute structure contains the UUID, data, and other information for the attribute. The data structures in the ATTS database implementation are illustrated in Figure 3.<br />
<br />
 The group structure contains a pointer to the attribute array, the handle range of the attributes it references, and other data. A database implementation typically uses one group structure per service, although this is not a requirement. A group can contain multiple services, or a service can be implemented with multiple groups.</p>
<div class="image">
<img src="diagram_atts_database.png" alt="diagram_atts_database.png"/>
<div class="caption">
Figure 3. ATTS attribute database data structures</div></div>
 <h2><a class="anchor" id="ATT_ATTS_UUID"></a>
Attribute UUID</h2>
<p>An attribute UUID is either 16 bits or 128 bits in length. The UUID value is stored as a byte array in little endian format. For example:<br />
<br />
</p>
<div class="fragment"><div class="line"><span class="comment">/* A 16-bit UUID value 0x0016 */</span></div><div class="line">uint8 uuid16[] = {0x16, 0x00};</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">/* A 128-bit UUID value 00001234-0000-1000-8000-00805F9B34FB */</span></div><div class="line">uint8 uuid128[] = {0xFB, 0x34, 0x9B, 0x5F, 0x80, 0x00, 0x00, 0x80,</div><div class="line">                   0x00, 0x10, 0x00, 0x00, 0x34, 0x12, 0x00, 0x00};</div></div><!-- fragment --><h2><a class="anchor" id="ATT_ATTS_VALUE"></a>
Attribute Value</h2>
<p>The attribute value is stored as a byte array. If the attribute is an integer, the value is stored in little endian format.</p>
<h2><a class="anchor" id="ATT_ATTS_HANDLES"></a>
Attribute Handle</h2>
<p>The attribute protocol uses handles to uniquely identify attributes. To save memory, the attribute server does not store a handle for each attribute. Rather, it uses the starting handle value in each group to derive the handle of a particular attribute in the group. The start handle is the handle of the attribute at index zero of the groupâ€™s attribute array. The handle of each subsequent attribute is simply the start handle plus the attributes index in the array.</p>
<h2><a class="anchor" id="ATT_ATTS_CCCD"></a>
Client Characteristic Configuration</h2>
<p>The <em>Client</em> <em>Characteristic</em> <em>Configuration</em> <em>Descriptor</em> (abbreviated as CCC or CCCD) enables or disables indications or notifications of the characteristic value associated with the descriptor.<br />
<br />
 The Bluetooth specification has certain requirements for CCCDs:</p><ol type="1">
<li>The server must maintain the value of the CCCD separately for each client.</li>
<li>If the server and client are bonded, the value of the CCCD is persistent across connections.</li>
<li>If the server and client are not bonded, the value of the CCCD is reset to zero when the client connects.</li>
</ol>
<p>The functions in this interface simplify and centralize the management of CCCDs. However, if a server application does not use notifications or indications, or does not support bonding, then these functions do not need to be used.<br />
<br />
 An application using this interface is responsible for defining certain data structures, as shown below in Figure 4.</p>
<div class="image">
<img src="diagram_atts_cccd.png" alt="diagram_atts_cccd.png"/>
<div class="caption">
Figure 4. CCCD data structures defined by the application</div></div>
<p> The data structures consist of bonded device CCCD tables, a CCCD settings table, a connection storage buffer, and a CCCD index enumeration. The Bonded device CCCD tables maintain persistent storage of the CCCD values for each bonded device. The CCCD settings table contains the CCCD attribute handle, security settings, and permitted CCCD values. The connection storage buffer holds separate CCCD values for all simultaneous connections. All tables are indexed by the CCCD index enumeration that defines the position in the table associated with each CCCD.</p>
<h2><a class="anchor" id="ATT_ATTS_DYNAMIC"></a>
Dynamic Attribute Interface Operation</h2>
<p>The dynamic attribute subsystem provides a mechanism through which an application can add services, characteristics, and attributes at runtime. The dynamic attribute subsystem is an alternative to <a class="el" href="group___s_t_a_c_k___a_t_t_s___a_p_i.html#ga6bc9e10effff05cd8e4b8541ba9d6d70">AttsAddGroup</a> which generally utilizes constant arrays that cannot change at runtime. The dynamic attribute subsystem maintains its attribute database in a volatile heap. The dynamic attribute interface provides functions for adding groups of attributes to this heap. <br />
<br />
 </p><dl class="section note"><dt>Note</dt><dd>Service discovery generally takes place shortly after a connection opens. Therefore, this interface should generally be used before a connection opens.<br />
<br />
 </dd>
<dd>
Use of the dynamic attribute subsystem is optional.</dd></dl>
<h1><a class="anchor" id="ATT_ATTC"></a>
ATT Client</h1>
<p>See <a class="el" href="group___s_t_a_c_k___a_t_t_c___a_p_i.html">ATT Client API</a> for Interface.</p>
<h2><a class="anchor" id="ATT_ATTC_Discovery"></a>
Client Discovery Interface</h2>
<p>The ATTC API contains a utility interface that simplifies common GATT client service and characteristic discovery procedures. It also contains interfaces that simplify the configuration of a service, for example reading or writing a set of characteristics or attributes after discovery is complete.<br />
<br />
 An application using this interface is responsible for defining certain data structures, as shown below in Figure 5.</p>
<div class="image">
<img src="diagram_attc_discovery.png" alt="diagram_attc_discovery.png"/>
<div class="caption">
Figure 5. Client discovery data structures defined by the application</div></div>
<p> The client discovery API uses a discovery control block that contains data used for the discovery and configuration procedure. The control block points to a discovery characteristic list, a configuration characteristic list, and a handle list.<br />
<br />
 The discovery characteristic list is a list of characteristics and descriptors that are to be discovered. Each item in the list contains the UUID of the characteristic or descriptor and its settings. As characteristics and descriptors are discovered, the handle list is populated with their respective handles.<br />
<br />
 The configuration characteristic list contains a list of characteristics and descriptors to read or write. Each item in the list contains the value (if it is to be written) and the handle index of the characteristic or descriptor in the handle list.</p>
<h1><a class="anchor" id="GATT_DIS"></a>
GATT Discovery Procedures</h1>
<p>The <em>Generic</em> <em>attribute</em> <em>profile</em> (GATT) of the Bluetooth core specification defines how attribute protocol operations are used to perform GATT procedures. The table below demonstrates how the ATTC API performs GATT discovery procedures.</p>
<a class="anchor" id="multi_row"></a>
<table class="doxtable">
<caption>GATT Procedures</caption>
<tr>
<th>GATT Procedure </th><th>ATTC API </th></tr>
<tr>
<td>Discover All Primary Services </td><td><a class="el" href="group___s_t_a_c_k___a_t_t_c___a_p_i.html#ga65423157ba56800e967da9da1df70ce7">AttcReadByGroupTypeReq()</a><br />
 startHandle=0x0001<br />
 endHandle=0xFFFF<br />
 uuidLen = 2<br />
 pUuid= pointer to <a class="el" href="group___s_t_a_c_k___a_t_t___a_p_i.html#gafe33780f454546286e703aa3b820a219">ATT_UUID_PRIMARY_SERVICE</a><br />
 continuing=<a class="el" href="group___w_s_f___t_y_p_e_s.html#gaa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a> </td></tr>
<tr>
<td>Discover Primary Services by Service UUID </td><td><a class="el" href="group___s_t_a_c_k___a_t_t_c___a_p_i.html#gaa9a77dd2622ce8fce08a943664857f5e">AttcFindByTypeValueReq()</a><br />
 startHandle = 0x0001<br />
 endHandle = 0xFFFF<br />
 uuid16 = <a class="el" href="group___s_t_a_c_k___a_t_t___a_p_i.html#gafe33780f454546286e703aa3b820a219">ATT_UUID_PRIMARY_SERVICE</a><br />
 valueLen = 2 or 16<br />
 pValue = pointer to service UUID<br />
 continuing = <a class="el" href="group___w_s_f___t_y_p_e_s.html#gaa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a> </td></tr>
<tr>
<td>Find Included Services </td><td><a class="el" href="group___s_t_a_c_k___a_t_t_c___a_p_i.html#gaa5a3fa5a4aa260347e247671eb1f78a7">AttcReadByTypeReq()</a><br />
 startHandle = service start handle<br />
 endHandle = service end handle<br />
 uuidLen = 2<br />
 pUuid = pointer to <a class="el" href="group___s_t_a_c_k___a_t_t___a_p_i.html#ga1761afc16454b7f7d77042d888d4f075">ATT_UUID_INCLUDE</a> </td></tr>
<tr>
<td>Discover All Characteristics of a Service </td><td><a class="el" href="group___s_t_a_c_k___a_t_t_c___a_p_i.html#gaa5a3fa5a4aa260347e247671eb1f78a7">AttcReadByTypeReq()</a><br />
 startHandle = service start handle<br />
 endHandle = service end handle<br />
 uuidLen = 2<br />
 pUuid= pointer to <a class="el" href="group___s_t_a_c_k___a_t_t___a_p_i.html#ga5a07b43d8e4f598ed20be665086cc110">ATT_UUID_CHARACTERISTIC</a><br />
 continuing = <a class="el" href="group___w_s_f___t_y_p_e_s.html#gaa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a> </td></tr>
<tr>
<td>Discover Characteristics by UUID </td><td><a class="el" href="group___s_t_a_c_k___a_t_t_c___a_p_i.html#gaa5a3fa5a4aa260347e247671eb1f78a7">AttcReadByTypeReq()</a><br />
 startHandle = service start handle<br />
 endHandle = service end handle<br />
 uuidLen = 2<br />
 pUuid= pointer to <a class="el" href="group___s_t_a_c_k___a_t_t___a_p_i.html#ga5a07b43d8e4f598ed20be665086cc110">ATT_UUID_CHARACTERISTIC</a><br />
 continuing = <a class="el" href="group___w_s_f___t_y_p_e_s.html#gaa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a> </td></tr>
<tr>
<td>Discover All Characteristic Descriptors </td><td><a class="el" href="group___s_t_a_c_k___a_t_t_c___a_p_i.html#gab7d41b9f530de71ff5327f3c60fce9bc">AttcFindInfoReq()</a><br />
 startHandle = characteristic value handle + 1<br />
 endHandle = characteristic end handle<br />
 continuing = <a class="el" href="group___w_s_f___t_y_p_e_s.html#gaa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a> </td></tr>
</table>
<h1><a class="anchor" id="ATT_USAGE"></a>
Usage Scenarios</h1>
<p>This section describes typical scenarios that use the API.</p>
<h2><a class="anchor" id="ATT_USAGE_SERVER_OP"></a>
Server Operations</h2>
<p>Figure 6 shows an example server operation.</p>
<div class="image">
<img src="operation_att_server.png" alt="operation_att_server.png"/>
<div class="caption">
Figure 6. Server Operations</div></div>
<p> First, a connection is established with an attribute protocol client on a peer device. The peer device sends an attribute protocol read request. In this example, the read request is handled internally by the stack and no interaction is required from the application.<br />
<br />
 Next, the peer device sends a write request. In this example, the attribute being written is configured to execute a write callback function. The callback executes and the application performs whatever operation is necessary for the attribute. On return of the callback the stack sends a write response packet.<br />
<br />
 Next, the application sends a handle value notification to the peer device by calling <a class="el" href="group___s_t_a_c_k___a_t_t_s___a_p_i.html#ga400acc152573cf26286ae04748599711" title="Send an attribute protocol Handle Value Indication. ">AttsHandleValueInd()</a>. The stack sends a handle value indication packet.<br />
<br />
 When the stack receives a handle value confirmation packet from the peer, it executes the application's ATT callback with event <a class="el" href="group___s_t_a_c_k___a_t_t___a_p_i.html#gga06fc87d81c62e9abb8790b6e5713c55babd9ada172603f660d2c6f81635a05a23">ATTS_HANDLE_VALUE_CNF</a>.</p>
<h2><a class="anchor" id="ATT_USAGE_CLIENT_OP"></a>
Client Operations</h2>
<p>Figure 7 shows some example client operations.</p>
<div class="image">
<img src="operation_att_client.png" alt="operation_att_client.png"/>
<div class="caption">
Figure 7. Client Operations</div></div>
<ol type="1">
<li>First, a connection is established with an attribute protocol server on a peer device.<ol type="a">
<li>The application initiates a request by calling <a class="el" href="group___s_t_a_c_k___a_t_t_c___a_p_i.html#ga65423157ba56800e967da9da1df70ce7" title="Initiate an attribute protocol Read By Group Type Request. ">AttcReadByGroupTypeReq()</a> with the continuing parameter set to <a class="el" href="group___w_s_f___t_y_p_e_s.html#gaa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>.</li>
<li>The client sends an attribute protocol read by group type request, receives a response, and executes the ATT callback with event <a class="el" href="group___s_t_a_c_k___a_t_t___a_p_i.html#gga06fc87d81c62e9abb8790b6e5713c55ba031c99f30de34612d5995f4d5d91a54b">ATTC_READ_BY_GROUP_TYPE_RSP</a>. Because the read by group type procedure is not complete, the client automatically sends another read by group type request packet to continue the procedure.</li>
<li>When the procedure is complete, the ATT callback is executed with event <a class="el" href="group___s_t_a_c_k___a_t_t___a_p_i.html#gga06fc87d81c62e9abb8790b6e5713c55ba031c99f30de34612d5995f4d5d91a54b">ATTC_READ_BY_GROUP_TYPE_RSP</a> and the continuing parameter set to <a class="el" href="group___w_s_f___t_y_p_e_s.html#gaa93f0eb578d23995850d61f7d61c55c1">FALSE</a>.</li>
</ol>
</li>
<li>Next the application sends another request by calling <a class="el" href="group___s_t_a_c_k___a_t_t_c___a_p_i.html#gaa5a3fa5a4aa260347e247671eb1f78a7" title="Initiate an attribute protocol Read By Type Request. ">AttcReadByTypeReq()</a>.<ol type="a">
<li>The stack sends a read by type request packet, receives a response, and executes the ATT callback with event <a class="el" href="group___s_t_a_c_k___a_t_t___a_p_i.html#gga06fc87d81c62e9abb8790b6e5713c55ba6a6340ebdbd491e446230fdc454b9430">ATTC_READ_BY_TYPE_RSP</a>.</li>
<li>In this example, the procedure is complete in the first packet transaction and the continuing parameter is set to <a class="el" href="group___w_s_f___t_y_p_e_s.html#gaa93f0eb578d23995850d61f7d61c55c1">FALSE</a>.</li>
</ol>
</li>
<li>Finally, the application writes an attribute by calling <a class="el" href="group___s_t_a_c_k___a_t_t_c___a_p_i.html#gad90df84c1ce36a01a70346aa1696d49c" title="Initiate an attribute protocol Write Command. ">AttcWriteCmd()</a>.<ol type="a">
<li>The stack sends a write command packet. This packet does not have a corresponding response packet.</li>
<li>When the stack has sent the packet, it executes the ATT callback with event <a class="el" href="group___s_t_a_c_k___a_t_t___a_p_i.html#gga06fc87d81c62e9abb8790b6e5713c55ba3e5ba99b53a6ac95bd03cebbd1bd8925">ATTC_WRITE_CMD_RSP</a>.</li>
</ol>
</li>
</ol>
<h2><a class="anchor" id="ATT_USAGE_CLIENT_PREPEXECWRITE"></a>
Client Prepare and Execute Write</h2>
<p>Figure 8 shows an example prepare and execute write procedure.</p>
<div class="image">
<img src="operation_att_client_prepexecwrite.png" alt="operation_att_client_prepexecwrite.png"/>
<div class="caption">
Figure 8. Client Prepare and Execute Write</div></div>
<ol type="1">
<li>The application calls <a class="el" href="group___s_t_a_c_k___a_t_t_c___a_p_i.html#ga778599d1122102a27508e7c0e15c85c7" title="Initiate an attribute protocol Prepare Write Request. ">AttcPrepareWriteReq()</a> to write an attribute value.</li>
<li>The stack sends prepare write request packets until all the data has been sent to the peer device.</li>
<li>The ATT callback is executed with event <a class="el" href="group___s_t_a_c_k___a_t_t___a_p_i.html#gga06fc87d81c62e9abb8790b6e5713c55bafc8115140d9f30a2d01ccc6999203429">ATTC_PREPARE_WRITE_RSP</a> each time a response packet is received.</li>
<li>When callback event parameter continuing is set to <a class="el" href="group___w_s_f___t_y_p_e_s.html#gaa93f0eb578d23995850d61f7d61c55c1">FALSE</a>, the procedure is complete.</li>
<li>Next the application calls <a class="el" href="group___s_t_a_c_k___a_t_t_c___a_p_i.html#gaf65c9b2a80d7a8fc8b7cf1d223662925" title="Initiate an attribute protocol Execute Write Request. ">AttcExecuteWriteReq()</a> to execute the write procedure in the peer device's attribute server.</li>
<li>The stack sends and executes the write request packet.</li>
<li>When it receives a response, it executes the ATT callback with event <a class="el" href="group___s_t_a_c_k___a_t_t___a_p_i.html#gga06fc87d81c62e9abb8790b6e5713c55ba0c9374d7d4a9a7cb0c0d08718ff2437d">ATTC_EXECUTE_WRITE_RSP</a>.</li>
</ol>
<h2><a class="anchor" id="ATT_USAGE_CLIENT_DISCCONFIG"></a>
Client Discovery and Configuration</h2>
<p>Figure 9 shows and example of discovery and configuration using the ATT client discovery API.</p>
<div class="image">
<img src="operation_att_client_discconfig.png" alt="operation_att_client_discconfig.png"/>
<div class="caption">
Figure 9. Client Discovery and Configuration Procedures</div></div>
<ol type="1">
<li>First, service discovery is initiated by calling <a class="el" href="group___s_t_a_c_k___a_t_t_c___a_p_i.html#ga5ef13aaebcd9c58c5f902e5001054a97" title="This utility function discovers the given service on a peer device. Function AttcFindByTypeValueReq()...">AttcDiscService()</a> with the UUID of the service to be discovered.</li>
<li>The ATT callback is executed with event <a class="el" href="group___s_t_a_c_k___a_t_t___a_p_i.html#gga06fc87d81c62e9abb8790b6e5713c55baf04a92fe3c0eb5944c27bc1a88bf498e">ATTC_FIND_BY_TYPE_VALUE_RSP</a> containing discovery results.</li>
<li>The callback message is passed to function <a class="el" href="group___s_t_a_c_k___a_t_t_c___a_p_i.html#ga1a986c79e925a72b577b10aa8a36302f" title="This utility function processes a service discovery result. It should be called when an ATTC_FIND_BY_...">AttcDiscServiceCmpl()</a>, which returns <a class="el" href="group___s_t_a_c_k___a_t_t___a_p_i.html#ga8ccdb1ef81e6d6fb64b920a5e39f9bc6">ATT_SUCCESS</a> indicating that service discovery completed successfully.</li>
<li>Then the application proceeds with characteristic discovery by calling <a class="el" href="group___s_t_a_c_k___a_t_t_c___a_p_i.html#ga0d9e02dd17b0242aa70fb54c4b3efb1b" title="This utility function starts characteristic and characteristic descriptor discovery for a service on ...">AttcDiscCharStart()</a>.</li>
<li>The ATT callback is executed with event <a class="el" href="group___s_t_a_c_k___a_t_t___a_p_i.html#gga06fc87d81c62e9abb8790b6e5713c55ba6a6340ebdbd491e446230fdc454b9430">ATTC_READ_BY_TYPE_RSP</a> containing characteristic discovery results.</li>
<li>The callback message is passed to function <a class="el" href="group___s_t_a_c_k___a_t_t_c___a_p_i.html#gaa219d5ff1e23a33917c2ace64e4ed291" title="This utility function processes a characteristic discovery result. It should be called when an ATTC_R...">AttcDiscCharCmpl()</a>, which returns <a class="el" href="group___s_t_a_c_k___a_t_t___a_p_i.html#ga4fb32cdc110caa41dc867fe0da04ea5b">ATT_CONTINUING</a> indicating that characteristic discovery is continuing. This procedure repeats until <a class="el" href="group___s_t_a_c_k___a_t_t_c___a_p_i.html#gaa219d5ff1e23a33917c2ace64e4ed291" title="This utility function processes a characteristic discovery result. It should be called when an ATTC_R...">AttcDiscCharCmpl()</a> returns <a class="el" href="group___s_t_a_c_k___a_t_t___a_p_i.html#ga8ccdb1ef81e6d6fb64b920a5e39f9bc6">ATT_SUCCESS</a> indicating that characteristic discovery completed successfully.</li>
<li>Then the application proceeds with characteristic configuration by calling <a class="el" href="group___s_t_a_c_k___a_t_t_c___a_p_i.html#ga0aafac77164a5af13c7f6c09b3a661a9" title="This utility function starts characteristic configuration for characteristics on a peer device...">AttcDiscConfigStart()</a>. A characteristic read or write is performed according to the contents of the configuration characteristic list, and the ATT callback is executed.</li>
<li>The callback message is passed to function <a class="el" href="group___s_t_a_c_k___a_t_t_c___a_p_i.html#ga2f3d56ae678879fa53a48b70bec8d7c1" title="This utility function initiates the next characteristic configuration procedure. It should be called ...">AttcDiscConfigCmpl()</a>, which returns <a class="el" href="group___s_t_a_c_k___a_t_t___a_p_i.html#ga4fb32cdc110caa41dc867fe0da04ea5b">ATT_CONTINUING</a> indicating that configuration is not complete. The procedure repeats until <a class="el" href="group___s_t_a_c_k___a_t_t_c___a_p_i.html#ga2f3d56ae678879fa53a48b70bec8d7c1" title="This utility function initiates the next characteristic configuration procedure. It should be called ...">AttcDiscConfigCmpl()</a> returns <a class="el" href="group___s_t_a_c_k___a_t_t___a_p_i.html#ga8ccdb1ef81e6d6fb64b920a5e39f9bc6">ATT_SUCCESS</a>. </li>
</ol>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<ul>
<table width="100%">
    <tr>
        <td align="left" valign="middle">Copyright &copy; 2017-2018 Arm Ltd. All rights reserved.</td>
        <td align="center" valign="middle">Arm Confidential</td>
        <td align="right" valign="middle">Cordio Stack and Cordio Profiles</td>
    </tr>
</table>
</ul>
</div>
</body>
</html>
